<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.19" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme='dark'] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background-color: var(--vp-c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme')
      const systemDarkMode =
        'matchMedia' in window
          ? window.matchMedia('(prefers-color-scheme: dark)').matches
          : false

      if (userMode === 'light') {
        document.documentElement.dataset.theme = 'light'
      } else if (userMode === 'dark' || systemDarkMode) {
        document.documentElement.dataset.theme = 'dark'
      }
    </script>
    <link rel="icon" href="/images/favicon.ico"><title>Java 高效并发 | JAVA技术学习笔记</title><meta name="description" content="https://www.eyeo.cn/">
    <link rel="preload" href="/assets/style-BioksKYN.css" as="style"><link rel="stylesheet" href="/assets/style-BioksKYN.css">
    <link rel="modulepreload" href="/assets/app-DX-8M_Q1.js"><link rel="modulepreload" href="/assets/1-Java高效并发.html-CFJNjkgm.js">
    <link rel="prefetch" href="/assets/index.html-CjnqqdCk.js" as="script"><link rel="prefetch" href="/assets/index.html-BzIVB0tw.js" as="script"><link rel="prefetch" href="/assets/index.html-VnzS0fkj.js" as="script"><link rel="prefetch" href="/assets/Github之旅.html-B_jITiXF.js" as="script"><link rel="prefetch" href="/assets/01.编写可维护的JavaScript.html-CZ6yL7Ra.js" as="script"><link rel="prefetch" href="/assets/02.Hexo挂掉自动重启.html-DCq1iwz2.js" as="script"><link rel="prefetch" href="/assets/03.VuePress结合Github自动化部署.html-BhIAn2Kk.js" as="script"><link rel="prefetch" href="/assets/index.html-D7eEe_j6.js" as="script"><link rel="prefetch" href="/assets/1-设计模式概述.html-DGCBIdOY.js" as="script"><link rel="prefetch" href="/assets/1-MySQL概览.html-B7zB_PRj.js" as="script"><link rel="prefetch" href="/assets/1-String.matches()性能测试.html-CNwd_IQ-.js" as="script"><link rel="prefetch" href="/assets/2-万能的HelloWorld.html-RGoLkAkV.js" as="script"><link rel="prefetch" href="/assets/404.html-DIBP2exV.js" as="script"><link rel="prefetch" href="/assets/setupDevtools-7MC2TMWH-DI9AP5U-.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="vp-theme-container external-link-icon" vp-container><!--[--><header class="vp-navbar" vp-navbar><div class="vp-toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/"><!----><span class="vp-site-name vp-hide-mobile" aria-hidden="true">JAVA技术学习笔记</span></a></span><div class="vp-navbar-items-wrapper" style=""><!--[--><!--]--><nav class="vp-navbar-items vp-hide-mobile" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/" aria-label="首页"><!--[--><!--[--><!--]--><!--]-->首页<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link route-link-active auto-link" href="/backend/" aria-label="Java技术栈"><!--[--><!--[--><!--]--><!--]-->Java技术栈<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/boutique/" aria-label="杂货铺"><!--[--><!--[--><!--]--><!--]-->杂货铺<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="auto-link external-link" href="https://github.com/AmosWang0626/AmosWang0626.github.io" aria-label="GitHub" rel="noopener noreferrer" target="_blank"><!--[--><!--[--><!--]--><!--]-->GitHub<!--[--><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button type="button" class="vp-toggle-color-mode-button" title="toggle color mode"><svg class="light-icon" viewbox="0 0 32 32" style=""><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg class="dark-icon" viewbox="0 0 32 32" style="display:none;"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="vp-sidebar-mask"></div><!--[--><aside class="vp-sidebar" vp-sidebar><nav class="vp-navbar-items" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/" aria-label="首页"><!--[--><!--[--><!--]--><!--]-->首页<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link route-link-active auto-link" href="/backend/" aria-label="Java技术栈"><!--[--><!--[--><!--]--><!--]-->Java技术栈<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/boutique/" aria-label="杂货铺"><!--[--><!--[--><!--]--><!--]-->杂货铺<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="auto-link external-link" href="https://github.com/AmosWang0626/AmosWang0626.github.io" aria-label="GitHub" rel="noopener noreferrer" target="_blank"><!--[--><!--[--><!--]--><!--]-->GitHub<!--[--><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="vp-sidebar-items"><!--[--><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">Java基础 <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/backend/java/base/1-String.matches()%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95.html" aria-label="String.matches() 性能测试"><!--[--><!--[--><!--]--><!--]-->String.matches() 性能测试<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/backend/java/base/2-%E4%B8%87%E8%83%BD%E7%9A%84HelloWorld.html" aria-label="万能的HelloWorld"><!--[--><!--[--><!--]--><!--]-->万能的HelloWorld<!--[--><!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading active">Java并发编程 <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link route-link-active auto-link vp-sidebar-item active" href="/backend/java/concurrent/1-Java%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91.html" aria-label="Java高效并发"><!--[--><!--[--><!--]--><!--]-->Java高效并发<!--[--><!--[--><!--]--><!--]--></a><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="#_2-1-回顾计算机内存模型" aria-label="2.1 回顾计算机内存模型"><!--[--><!--[--><!--]--><!--]-->2.1 回顾计算机内存模型<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#_2-2-主内存与工作内存" aria-label="2.2 主内存与工作内存"><!--[--><!--[--><!--]--><!--]-->2.2 主内存与工作内存<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#_2-3-原子性、可见性与有序性" aria-label="2.3 原子性、可见性与有序性"><!--[--><!--[--><!--]--><!--]-->2.3 原子性、可见性与有序性<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#_2-4-先行发生原则-happens-before" aria-label="2.4 先行发生原则（happens-before）"><!--[--><!--[--><!--]--><!--]-->2.4 先行发生原则（happens-before）<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#_3-1-大娃-synchronized" aria-label="3.1 大娃 Synchronized"><!--[--><!--[--><!--]--><!--]-->3.1 大娃 Synchronized<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#_3-2-二蛋-volatile" aria-label="3.2 二蛋 Volatile"><!--[--><!--[--><!--]--><!--]-->3.2 二蛋 Volatile<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#_4-1-cas" aria-label="4.1 CAS"><!--[--><!--[--><!--]--><!--]-->4.1 CAS<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#_4-2-aqs" aria-label="4.2 AQS"><!--[--><!--[--><!--]--><!--]-->4.2 AQS<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#_4-3-reentrantlock" aria-label="4.3 ReentrantLock"><!--[--><!--[--><!--]--><!--]-->4.3 ReentrantLock<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#_4-4-其他并发集合" aria-label="4.4 其他并发集合"><!--[--><!--[--><!--]--><!--]-->4.4 其他并发集合<!--[--><!--[--><!--]--><!--]--></a><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="#简单代码" aria-label="简单代码"><!--[--><!--[--><!--]--><!--]-->简单代码<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#threadpoolexecutor-参数详解" aria-label="ThreadPoolExecutor 参数详解"><!--[--><!--[--><!--]--><!--]-->ThreadPoolExecutor 参数详解<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#corepoolsize-maximumpoolsize" aria-label="corePoolSize maximumPoolSize"><!--[--><!--[--><!--]--><!--]-->corePoolSize maximumPoolSize<!--[--><!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">设计模式 <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/backend/design_mode/1-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0.html" aria-label="设计模式概述"><!--[--><!--[--><!--]--><!--]-->设计模式概述<!--[--><!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">MySQL <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/backend/mysql/1-MySQL%E6%A6%82%E8%A7%88.html" aria-label="MySQL概览"><!--[--><!--[--><!--]--><!--]-->MySQL概览<!--[--><!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="vp-page"><!--[--><!--]--><div vp-content><!--[--><!--]--><div><h1 id="java-高效并发" tabindex="-1"><a class="header-anchor" href="#java-高效并发"><span>Java 高效并发</span></a></h1><blockquote><p>学习是一个发散的过程，层层递进，连贯起来，如故事一样。</p></blockquote><h1 id="一、并发有什么用" tabindex="-1"><a class="header-anchor" href="#一、并发有什么用"><span>一、并发有什么用？</span></a></h1><p>并发处理的广泛应用是使得 Amdahl 定律代替摩尔定律成为计算机性能发展源动力的根本原因，也是人类“压榨”计算机运算能力的最有力武器。——引自《深入理解Java虚拟机》</p><p><strong>摩尔定律：</strong> 摩尔定律是指IC上可容纳的晶体管数目，约每隔18个月便会增加一倍，性能也将提升一倍。由英特尔名誉董事长戈登·摩尔1965年提出。<strong>但是，时间是无穷的，IC上可容纳的晶体管数目也是有极限的。</strong></p><p><strong>Amdahl 定律：</strong> 在一个系统中，并行化和串行化的比重，描述了多处理器系统能获得的运算加速能力。<strong>对于串行化的任务，计算机处理器再多也无用；对于可并行的任务，处理器越多，自然是越快的。</strong></p><p>并发充分利用CPU资源，降低系统响应时间，提升系统吞吐量。</p><hr><h1 id="二、java-内存模型-jmm" tabindex="-1"><a class="header-anchor" href="#二、java-内存模型-jmm"><span>二、Java 内存模型（JMM）</span></a></h1><blockquote><p>Java Memory Model，JMM。用它来屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。在此之前，主流程序语言（如C和C++等）直接使用物理硬件和操作系统的内存模型。</p></blockquote><h2 id="_2-1-回顾计算机内存模型" tabindex="-1"><a class="header-anchor" href="#_2-1-回顾计算机内存模型"><span>2.1 回顾计算机内存模型</span></a></h2><p>内存与处理器速度的矛盾，是引入高速缓存的重要原因。</p><p>高速缓存工作原理：将运算需要使用到的数据复制到缓存中，让运算能够快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无需等待缓慢的内存读写了。</p><p>每个处理器都有自己的高速缓存，而它们又共享同一个主内存，当同时操作同一块主内存区域时，以谁的数据为准呢？缓存一致性问题闪亮登场。</p><p>缓存一致性问题解决方案：</p><ul><li>总线加锁。早期CPU多为此方案，一个线程处理，其他线程阻塞，问题就是效率低下；</li><li>缓存一致性协议。处理器访问缓存时需遵循对应协议，最出名的就是 Intel 的 MESI 了。</li></ul><p><img src="/images/article/backend/java/concurrent/computer-memory-model.png" alt="计算机内存模型"></p><ul><li><p>此处的主内存，对应物理机的 RAM 运行内存，就是常说的8GB、16GB内存；</p><ul><li>RAM（Random Access Memory）随机存储内存，对应电脑的运行内存，断电会丢失存储的内容；</li><li>ROM（Read Only Memory）只读内存，对应电脑的硬盘存储。</li></ul></li><li><p>当然，和高速缓存直接通信的是处理器中的寄存器；高速缓存也常分为一级缓存、二级缓存和三级缓存。</p></li><li><p><a href="https://zh.wikipedia.org/wiki/MESI%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener noreferrer">MESI</a> 多核 CPU 多级缓存一致性协议，共享数据通过 cache line 标记。</p><table><thead><tr><th style="text-align:left;">状态</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:left;">M 修改 Modified</td><td style="text-align:left;">缓存行是脏的（<em>dirty</em>），与主存的值不同。如果别的 CPU内核要读主存这块数据，该缓存行必须写回（<em>flush</em>）主存，变为共享状态(S)。</td></tr><tr><td style="text-align:left;">E 独享 Exclusive</td><td style="text-align:left;">缓存行只在当前缓存中，并且是干净的（<em>clean</em>），与主存的值相同。当别的缓存读取它时，变为共享状态(S)；当前写数据时，变为修改状态(M)。</td></tr><tr><td style="text-align:left;">S 共享 Shared</td><td style="text-align:left;">缓存行也存在于其它缓存中，并且是干净的。缓存行可以在任意时刻抛弃。</td></tr><tr><td style="text-align:left;">I 无效 Invalid</td><td style="text-align:left;">缓存行是无效的。</td></tr></tbody></table></li></ul><h2 id="_2-2-主内存与工作内存" tabindex="-1"><a class="header-anchor" href="#_2-2-主内存与工作内存"><span>2.2 主内存与工作内存</span></a></h2><p>通俗地说，工作内存就是线程私有的内存，主内存就是线程共享的内存。</p><p>工作方式：</p><ul><li>线程修改工作内存的数据，因为是线程私有的，直接修改即可；</li><li>线程修改主内存的数据，线程不能直接修改主内存数据，需要先将主内存数据 Load 到工作内存，修改完，将数据 Save 到主内存，此时就涉及脏读和并发写的问题了。如何保证呢？也就是下文的内容了——加锁。</li></ul><p><img src="/images/article/backend/java/concurrent/java-memory-model.png" alt="Java内存模型"></p><p>对照下图，是不是很熟悉？线程隔离数据区、线程共享数据区。</p><p><img src="/images/article/backend/java/concurrent/jvm-runtime-data-area.png" alt="Java 运行时数据区"></p><h2 id="_2-3-原子性、可见性与有序性" tabindex="-1"><a class="header-anchor" href="#_2-3-原子性、可见性与有序性"><span>2.3 原子性、可见性与有序性</span></a></h2><ul><li><p><strong>原子性</strong>（<em>不可分割</em>）</p><ul><li><p>基本数据类型的访问、读写都是具备原子性的。</p><p>由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write这六个。</p><p><strong>注意：</strong> 多个原子操作放一起，就不能保证原子性了，例如 i++ 就不是原子操作。</p></li><li><p>synchronized 块之间的操作具备原子性。</p><p>如果应用场景需要一个更大范围的原子性保证（经常会遇到），Java内存模型还提供了 lock 和 unlock 操作来满足这种需求，尽管虚拟机未把 lock 和 unlock 操作直接开放给用户使用，但是却提供了更高层次的字节码指令 monitorenter 和 monitorexit 来隐式地使用这两个操作，也即 synchronized 的底层实现。</p></li></ul></li><li><p><strong>可见性</strong>（<em>当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改</em>）</p><p>Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的。</p><ul><li><p>volatile 实现可见性</p><p>volatile 的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。</p></li><li><p>synchronized 实现可见性 对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）</p></li><li><p>final 实现可见性</p><p>被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那么在其他线程中就能看见final字段的值。</p></li></ul></li><li><p><strong>有序性</strong>（<em>线程内表现为串行的语义 As-If-Serial</em>）</p><p>程序代码的执行顺序可能和我们写的代码顺序不一致。因为在同一个线程的方法执行过程中无法感知到这点，这就是Java内存模型中描述的所谓“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics）。</p><ul><li><p>volatile 实现有序性</p><p>volatile 包含了禁止指令重排序的语义。相当于一个内存屏障（Memory Barrier或Memory Fence，指重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个处理器访问内存时，并不需要内存屏障；但如果有两个或更多处理器访问同一块内存，且其中有一个在观测另一个，就需要内存屏障来保证一致性了。</p></li><li><p>synchronized 实现有序性</p><p>一个变量在同一个时刻只允许一条线程对其进行lock操作，持有同一个锁的两个同步块只能串行地进入。</p></li></ul></li></ul><h2 id="_2-4-先行发生原则-happens-before" tabindex="-1"><a class="header-anchor" href="#_2-4-先行发生原则-happens-before"><span>2.4 先行发生原则（happens-before）</span></a></h2><p>Java 天生支持先行发生原则，具体原则如下。如果两个操作之间的关系不在此列，并且无法从下列规则推导出 来，则它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序。</p><ul><li>程序次序规则（在一个线程内，按照程序代码顺序，书写在前的先行于书写在后的。准确讲，是控制流顺序）</li><li>管程锁定规则（一个 unlock 操作先行于后边对同一个锁的 lock 操作。后边指时间上的先后顺序）</li><li>volatile 变量规则（对一个变量的写操作先行于后边读操作。后边同样指时间上的先后顺序）</li><li>线程启动规则（Thread.start() 先行于此线程的每一个动作）</li><li>线程终止规则（线程中的所有操作都先行于对此线程的终止监测）</li><li>线程中断规则（Thread.interrupt() 方法的调用先行于中断代码的监测）</li><li>对象终结规则（一个对象的初始化完成先行于它的 finalize()）</li><li>传递性（A先行发生于B，B先行发生于C，则可得出操作A先行发生于C的结论）</li></ul><hr><h1 id="三、亲儿子解决方案" tabindex="-1"><a class="header-anchor" href="#三、亲儿子解决方案"><span>三、亲儿子解决方案</span></a></h1><h2 id="_3-1-大娃-synchronized" tabindex="-1"><a class="header-anchor" href="#_3-1-大娃-synchronized"><span>3.1 大娃 Synchronized</span></a></h2><blockquote><p>JDK 1.6 之前为重量级锁；之后为偏向锁，如果竞争激烈，会自动升级。（偏向锁 &gt; 轻量级锁 &gt; 重量级锁）</p></blockquote><ol><li><p>加锁方式</p><ul><li>同步方法 <ol><li>静态方法</li><li>非静态方法</li></ol></li><li>同步代码块 <ol><li>对象锁</li><li>类锁（本质上也是对象锁，ClassLoader 加载的类，都有一个 Class 对象）</li></ol></li></ul></li><li><p>解决问题</p><p>原子性：同一时间，只允许一个线程持有某个对象锁，保证原子性。</p><p>可见性：锁释放之前，对共享变量的修改，对于随后获取该锁的线程是可见的。</p><p>有序性：持有同一个锁的两个同步块只能串行地进入，保证了有序性。</p></li><li><p>实现原理</p><p>这两个都是使用管程（Monitor，更常见的是直接将它称为“锁”）来实现的。</p><ul><li><p>同步方法</p><p>方法级的同步是隐式的，无须通过字节码指令来控制，它实现在方法调用和返回操作之中。</p><p>虚拟机可以从方法常量池中的方法表结构中的 ACC_SYNCHRONIZED 访问标志得知一个方法是否被声明为同步方法。如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程。在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的管程将在异常抛到同步方法边界之外时自动释放。</p></li><li><p>同步代码块</p><p>Java虚拟机的指令集中有 monitorenter 和 monitorexit 两条指令来支持 synchronized 关键字的语义，正确实现 synchronized 关键字需要 javac 编译器与 Java虚拟机两者共同协作支持。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">void</span> <span class="token function">onlyMe</span><span class="token punctuation">(</span><span class="token class-name">Foo</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line">Method <span class="token keyword">void</span> <span class="token function">onlyMe</span><span class="token punctuation">(</span>Foo<span class="token punctuation">)</span></span>
<span class="line"><span class="token number">0</span> aload_1		<span class="token comment">// 将对象f入栈</span></span>
<span class="line"><span class="token number">1</span> dup			<span class="token comment">// 复制栈顶元素（即f的引用）</span></span>
<span class="line"><span class="token number">2</span> astore_2		<span class="token comment">// 将栈顶元素存储到局部变量表变量槽 2中</span></span>
<span class="line"><span class="token number">3</span> monitorenter	<span class="token comment">// 以栈定元素（即f）作为锁，开始同步</span></span>
<span class="line"><span class="token number">4</span> aload_0		<span class="token comment">// 将局部变量槽 0（即this指针）的元素入栈</span></span>
<span class="line"><span class="token number">5</span> invokevirtual #<span class="token number">5</span>	<span class="token comment">// 调用doSomething()方法</span></span>
<span class="line"><span class="token number">8</span> aload_2 		<span class="token comment">// 将局部变量Slow 2的元素（即f）入栈</span></span>
<span class="line"><span class="token number">9</span> monitorexit 	<span class="token comment">// 退出同步</span></span>
<span class="line"><span class="token number">10</span> <span class="token keyword">goto</span> <span class="token number">18</span> 		<span class="token comment">// 方法正常结束，跳转到18返回</span></span>
<span class="line"><span class="token number">13</span> astore_3 	<span class="token comment">// 从这步开始是异常路径，见下面异常表的Taget 13</span></span>
<span class="line"><span class="token number">14</span> aload_2 		<span class="token comment">// 将局部变量Slow 2的元素（即f）入栈</span></span>
<span class="line"><span class="token number">15</span> monitorexit 	<span class="token comment">// 退出同步</span></span>
<span class="line"><span class="token number">16</span> aload_3 		<span class="token comment">// 将局部变量Slow 3的元素（即异常对象）入栈</span></span>
<span class="line"><span class="token number">17</span> athrow 		<span class="token comment">// 把异常对象重新抛出给onlyMe()方法的调用者</span></span>
<span class="line"><span class="token number">18</span> <span class="token keyword">return</span> 		<span class="token comment">// 方法正常返回</span></span>
<span class="line">Exception table<span class="token operator">:</span></span>
<span class="line">FromTo Target Type</span>
<span class="line"><span class="token number">4</span> <span class="token number">10</span> <span class="token number">13</span> any</span>
<span class="line"><span class="token number">13</span> <span class="token number">16</span> <span class="token number">13</span> any</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编译器必须确保无论方法通过何种方式完成，方法中调用过的每条 monitorenter 指令都必须有其对应的 monitorexit 指令，而无论这个方法是正常结束还是异常结束。</p></li></ul></li></ol><h2 id="_3-2-二蛋-volatile" tabindex="-1"><a class="header-anchor" href="#_3-2-二蛋-volatile"><span>3.2 二蛋 Volatile</span></a></h2><blockquote><p>轻量级锁</p></blockquote><ol><li><p>加锁方式</p><p>定义在变量上</p></li><li><p>解决问题</p><p>可见性：新值能立即同步到主内存，以及每次使用前立即从主内存刷新。</p><p>有序性：禁止指令重排序，重排序时不能把后面的指令重排序到内存屏障之前的位置。</p></li><li><p>实现原理</p><p>禁止指令重排序，保障新值的可见性。结合 DCL 编译后的源码看一下 ↓↓↓↓↓</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">                <span class="token punctuation">}</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">        <span class="token keyword">return</span> instance<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token number">0x01a3de0f</span><span class="token operator">:</span> mov $<span class="token number">0x3375cdb0</span><span class="token punctuation">,</span><span class="token operator">%</span>esi        <span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>beb0cd75 <span class="token number">33</span></span>
<span class="line">                                        <span class="token punctuation">;</span> <span class="token punctuation">{</span><span class="token function">oop</span><span class="token punctuation">(</span><span class="token char">&#39;Singleton&#39;</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span>
<span class="line"><span class="token number">0x01a3de14</span><span class="token operator">:</span> mov <span class="token operator">%</span>eax<span class="token punctuation">,</span><span class="token number">0x150</span><span class="token punctuation">(</span><span class="token operator">%</span>esi<span class="token punctuation">)</span>        <span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">.89865001</span> <span class="token number">0000</span></span>
<span class="line"><span class="token number">0x01a3de1a</span><span class="token operator">:</span> shr $<span class="token number">0x9</span><span class="token punctuation">,</span><span class="token operator">%</span>esi               <span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>c1ee09</span>
<span class="line"><span class="token number">0x01a3de1d</span><span class="token operator">:</span> movb $<span class="token number">0x0</span><span class="token punctuation">,</span><span class="token number">0x1104800</span><span class="token punctuation">(</span><span class="token operator">%</span>esi<span class="token punctuation">)</span>   <span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>c6860048 <span class="token number">100100</span></span>
<span class="line"><span class="token number">0x01a3de24</span><span class="token operator">:</span> lock addl $<span class="token number">0x0</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">%</span>esp<span class="token punctuation">)</span>       <span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>f0830424 <span class="token number">00</span></span>
<span class="line">                                        <span class="token punctuation">;</span><span class="token operator">*</span>putstatic instance</span>
<span class="line">                                        <span class="token punctuation">;</span> <span class="token operator">-</span> Singleton<span class="token operator">::</span>getInstance@<span class="token number">24</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>关键指令：<code>lock addl $0x0,(%esp)</code></strong></p><p>这句指令中的<code>addl $0x0,(%esp)</code>（把ESP寄存器的值加0）显然是一个空操作，之所以用这个空操作而不是空操作专用指令<code>nop</code>，是因为IA32手册规定<code>lock</code>前缀不允许配合<code>nop</code>指令使用。</p><p>这里的关键在于 <strong><code>lock</code>前缀，它的作用是将本处理器的缓存写入了内存，该写入动作也会引起别的处理器或者别的内核缓存无效（Invalidate）</strong> ，这种操作相当于对缓存中的变量做了一次前面介绍Java内存模式中所说的<code>store</code>和<code>write</code>操作。所以通过这样一个空操作，可让前面volatile变量的修改对其他处理器立即可见。</p><p>与此同时，<strong><code>lock addl$0x0,(%esp)</code>指令把修改同步到内存时，意味着所有之前的操作都已经执行完成，这样便形成了“指令重排序无法越过内存屏障”的效果。</strong></p></li></ol><hr><h1 id="四、并发基础-cas-与-aqs" tabindex="-1"><a class="header-anchor" href="#四、并发基础-cas-与-aqs"><span>四、并发基础 CAS 与 AQS</span></a></h1><h2 id="_4-1-cas" tabindex="-1"><a class="header-anchor" href="#_4-1-cas"><span>4.1 CAS</span></a></h2><p>Compare-and-Swap 或者 Compare-and-Set 简称 CAS。</p><p><strong>CAS操作是原子性的</strong>，CAS指令需要有三个操作数，分别是内存位置（在Java中可以简单地理解为变量的内存地址，用V表示）、旧的预期值（用A表示）和准备设置的新值（用B表示）。CAS指令执行时，当且仅当V符合A时，处理器才会用B更新V的值，否则它就不执行更新。</p><p>在 JDK 5之后，Java类库中才开始使用CAS操作，该操作由<code>sun.misc.Unsafe</code>类里面的<code>compareAndSwapInt()</code>和<code>compareAndSwapLong()</code>等几个方法包装提供。<code>HotSpot</code>虚拟机在内部对这些方法做了特殊处理，即时编译出来的结果就是一条平台相关的处理器CAS指令，没有方法调用的过程，或者可以认为是无条件内联进去了。不过由于Unsafe类在设计上就不是提供给用户程序调用的类【<code>Unsafe::getUnsafe()</code>的代码中限制了只有启动类加载器（<code>Bootstrap ClassLoader</code>）加载的Class才能访问它】，因此在<code>JDK 9</code>之前只有Java类库可以使用CAS，譬如<code>J.U.C</code>包里面的整数原子类，其中的<code>compareAndSet()</code>和<code>getAndIncrement()</code>等方法都使用了Unsafe类的CAS操作来实现。而如果用户程序也有使用CAS操作的需求，那要么就采用反射手段突破<code>Unsafe</code>的访问限制，要么就只能通过Java类库API来间接使用它。直到<code>JDK 9</code>之后，Java类库才在<code>VarHandle</code>类里开放了面向用户程序使用的<code>CAS</code>操作。</p><p><a href="https://github.com/AmosWang0626/chaos/blob/master/chaos-advanced/src/main/java/com/amos/advanced/java/UnsafeCasStudy.java" target="_blank" rel="noopener noreferrer">JDK 8 使用 Unsafe.compareAndSwapInt() 示例</a></p><h2 id="_4-2-aqs" tabindex="-1"><a class="header-anchor" href="#_4-2-aqs"><span>4.2 AQS</span></a></h2><p>基本结构：状态位 state + Node 双向链表；</p><p>获取锁：通过 CAS 修改 state（state + 1）；要是没获取到锁，就放进双向链表里边；</p><p>释放锁：释放锁，修改 state（state - 1）。当 state = 0，操作队列，解锁队首。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">Node</span> head<span class="token punctuation">;</span> <span class="token comment">// 队首</span></span>
<span class="line"><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">Node</span> tail<span class="token punctuation">;</span> <span class="token comment">// 队尾</span></span>
<span class="line"><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span> <span class="token comment">// 状态位</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">volatile</span> <span class="token keyword">int</span> waitStatus<span class="token punctuation">;</span> <span class="token comment">// 等待状态</span></span>
<span class="line">    <span class="token keyword">volatile</span> <span class="token class-name">Node</span> prev<span class="token punctuation">;</span> <span class="token comment">// 前</span></span>
<span class="line">    <span class="token keyword">volatile</span> <span class="token class-name">Node</span> next<span class="token punctuation">;</span> <span class="token comment">// 后</span></span>
<span class="line">    <span class="token keyword">volatile</span> <span class="token class-name">Thread</span> thread<span class="token punctuation">;</span> <span class="token comment">// 当前线程</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_4-3-reentrantlock" tabindex="-1"><a class="header-anchor" href="#_4-3-reentrantlock"><span>4.3 ReentrantLock</span></a></h2><blockquote><p>针对的问题，jdk1.6之前，只要加上 synchronized，不管有没有并发，都会加上重量级锁，导致性能低下。</p><p>Doug Lea 大神开发了JUC包，给出了加锁第二方案。</p></blockquote><p><a href="https://blog.csdn.net/java_lyvee/article/details/98966684" target="_blank" rel="noopener noreferrer">子路老师：JUC AQS ReentrantLock源码分析（一）</a></p><blockquote><p>偷个懒，把子路老师的文章放这了。 还有一个原因就是子路老师说的，不要会一点技术，还没理解全面，就往博客上写，间接导致了博客泛滥，误人子弟。</p></blockquote><h2 id="_4-4-其他并发集合" tabindex="-1"><a class="header-anchor" href="#_4-4-其他并发集合"><span>4.4 其他并发集合</span></a></h2><ul><li>CountDownLatch 类似计数器，都执行完成时退出。</li><li>Semaphore 类似停车位，有进有出，满需等待。</li><li>CyclicBarrier 类似发令枪，线程都就绪时，并发执行。</li><li>ReentrantReadWriteLock 读写锁。</li></ul><hr><h1 id="五、线程池" tabindex="-1"><a class="header-anchor" href="#五、线程池"><span>五、线程池</span></a></h1><h3 id="简单代码" tabindex="-1"><a class="header-anchor" href="#简单代码"><span>简单代码</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token comment">// 创建线程工厂,并设置线程名字格式</span></span>
<span class="line"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>common<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">ThreadFactoryBuilder</span></span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token class-name">ThreadFactory</span> threadFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setNameFormat</span><span class="token punctuation">(</span><span class="token string">&quot;thread-pool-%d&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// if (corePoolSize &gt; maximumPoolSize) throw IllegalArgumentException(非法调度Exception)</span></span>
<span class="line"><span class="token class-name">ExecutorService</span> singleThreadPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">,</span></span>
<span class="line">        <span class="token number">0L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">,</span></span>
<span class="line">        <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">,</span> threadFactory<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>AbortPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">singleThreadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">singleThreadPool<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="threadpoolexecutor-参数详解" tabindex="-1"><a class="header-anchor" href="#threadpoolexecutor-参数详解"><span>ThreadPoolExecutor 参数详解</span></a></h3><blockquote><p><code>ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, </code><code> long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue,</code><code> ThreadFactory threadFactory, RejectedExecutionHandler handler)</code></p></blockquote><ul><li><p>int corePoolSize 核心线程数。</p><ul><li>默认情况下核心线程会一直存活，即使处于闲置状态也不会受存keepAliveTime限制。</li><li>除非将allowCoreThreadTimeOut设置为true。</li></ul></li><li><p>int maximumPoolSize 线程池所能容纳的最大线程数。</p><ul><li>超过这个数的线程将被阻塞。</li><li>当任务队列为没有设置大小的LinkedBlockingDeque时，这个值无效。</li></ul></li><li><p>long keepAliveTime 非核心线程的闲置超时时间，超过这个时间就会被回收。</p></li><li><p>TimeUnit unit 指定keepAliveTime的单位，如TimeUnit.SECONDS。</p><ul><li>当将allowCoreThreadTimeOut设置为true时对corePoolSize生效。</li></ul></li><li><p><code>BlockingQueue&lt;Runnable&gt; workQueue</code> 线程池中的任务队列。</p><ul><li>常用的有三种队列，SynchronousQueue,LinkedBlockingDeque,ArrayBlockingQueue。</li></ul></li><li><p>ThreadFactory threadFactory 线程工厂，提供创建新线程的功能。</p><ul><li>ThreadFactory是一个接口，只有一个方法。</li></ul></li><li><p>RejectedExecutionHandler handler 线程池对拒绝任务的处理策略。</p><ul><li>在 ThreadPoolExecutor 里面定义了 4 种 handler 策略，分别是: <ol><li>CallerRunsPolicy ：这个策略重试添加当前的任务，他会自动重复调用 execute() 方法，直到成功。</li><li>AbortPolicy ：对拒绝任务抛弃处理，并且抛出异常。</li><li>DiscardPolicy ：对拒绝任务直接无声抛弃，没有异常信息。</li><li>DiscardOldestPolicy ：对拒绝任务不抛弃，而是抛弃队列里面等待最久的一个线程，然后把拒绝任务加到队列</li></ol></li></ul></li></ul><h3 id="corepoolsize-maximumpoolsize" tabindex="-1"><a class="header-anchor" href="#corepoolsize-maximumpoolsize"><span>corePoolSize maximumPoolSize</span></a></h3><ul><li><p>如果线程数量&lt;=核心线程数量，那么直接启动一个核心线程来执行任务，不会放入队列中。</p></li><li><p>如果线程数量&gt;核心线程数，但&lt;=最大线程数，并且任务队列是LinkedBlockingDeque的时候， 超过核心线程数量的任务会放在任务队列中排队。</p></li><li><p>如果线程数量&gt;核心线程数，但&lt;=最大线程数，并且任务队列是SynchronousQueue的时候，线程池 会创建新线程执行任务，这些任务也不会被放在任务队列中。这些线程属于非核心线程，在任务完 成后，闲置时间达到了超时时间就会被清除。</p></li><li><p>如果线程数量&gt;核心线程数，并且&gt;最大线程数，当任务队列是LinkedBlockingDeque，会将超过 核心线程的任务放在任务队列中排队。也就是当任务队列是LinkedBlockingDeque并且没有大小 限制时，线程池的最大线程数设置是无效的，他的线程数最多不会超过核心线程数。</p></li><li><p>如果线程数量&gt;核心线程数，并且&gt;最大线程数，当任务队列是SynchronousQueue的时候，会因为 线程池拒绝添加任务而抛出异常。</p></li></ul><hr><h1 id="六、梳理关键词" tabindex="-1"><a class="header-anchor" href="#六、梳理关键词"><span>六、梳理关键词</span></a></h1><ul><li>偏向锁、轻量级锁、重量级锁、锁消除、锁升级、公平锁、非公平锁</li></ul></div><!--[--><!--]--></div><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><div class="vp-meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="vp-meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 1833063210@qq.com">amos.wang</span><!----><!--]--><!--]--></span></div></div></footer><!----><!--[--><!--]--></main><!--]--></div><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/assets/app-DX-8M_Q1.js" defer></script>
  </body>
</html>
