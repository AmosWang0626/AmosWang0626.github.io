<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.42">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/images/favicon.ico"><title>MySQL概览 | JAVA技术学习笔记</title><meta name="description" content="https://www.eyeo.cn/">
    <link rel="modulepreload" href="/assets/app.91e03dc1.js"><link rel="modulepreload" href="/assets/1-MySQL概览.html.416fd126.js"><link rel="modulepreload" href="/assets/1-MySQL概览.html.f8c94ba7.js"><link rel="prefetch" href="/assets/index.html.371a6c90.js"><link rel="prefetch" href="/assets/index.html.5ff82f8e.js"><link rel="prefetch" href="/assets/index.html.97ba2d3f.js"><link rel="prefetch" href="/assets/index.html.afd50fea.js"><link rel="prefetch" href="/assets/1-设计模式概述.html.47a60eba.js"><link rel="prefetch" href="/assets/01.编写可维护的JavaScript.html.2d0a0512.js"><link rel="prefetch" href="/assets/02.Hexo挂掉自动重启.html.e1c1f2dc.js"><link rel="prefetch" href="/assets/03.VuePress结合Github自动化部署.html.40054591.js"><link rel="prefetch" href="/assets/index.html.cd65401e.js"><link rel="prefetch" href="/assets/1-String.matches()性能测试.html.6edf82a5.js"><link rel="prefetch" href="/assets/2-万能的HelloWorld.html.885ad4b3.js"><link rel="prefetch" href="/assets/1-Java高效并发.html.62ccc23a.js"><link rel="prefetch" href="/assets/404.html.93146c89.js"><link rel="prefetch" href="/assets/index.html.935f8262.js"><link rel="prefetch" href="/assets/index.html.0bbdc70b.js"><link rel="prefetch" href="/assets/index.html.81a11c16.js"><link rel="prefetch" href="/assets/index.html.b62d3181.js"><link rel="prefetch" href="/assets/1-设计模式概述.html.96eca43c.js"><link rel="prefetch" href="/assets/01.编写可维护的JavaScript.html.5436ac53.js"><link rel="prefetch" href="/assets/02.Hexo挂掉自动重启.html.b09f8056.js"><link rel="prefetch" href="/assets/03.VuePress结合Github自动化部署.html.bec1b723.js"><link rel="prefetch" href="/assets/index.html.24c06987.js"><link rel="prefetch" href="/assets/1-String.matches()性能测试.html.a49991c8.js"><link rel="prefetch" href="/assets/2-万能的HelloWorld.html.72044ca2.js"><link rel="prefetch" href="/assets/1-Java高效并发.html.d99e8308.js"><link rel="prefetch" href="/assets/404.html.7ecf56b0.js"><link rel="prefetch" href="/assets/404.1fa53ff0.js"><link rel="prefetch" href="/assets/Layout.ee579d1b.js">
    <link rel="stylesheet" href="/assets/style.74d78db3.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><!----><span class="site-name can-hide">JAVA技术学习笔记</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/" class="" aria-label="首页"><!--[--><!--]--> 首页 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/backend/" class="router-link-active" aria-label="Java技术栈"><!--[--><!--]--> Java技术栈 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/ops/" class="" aria-label="Ops相关"><!--[--><!--]--> Ops相关 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/boutique/" class="" aria-label="杂货铺"><!--[--><!--]--> 杂货铺 <!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://github.com/AmosWang0626/AmosWang0626.github.io" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/" class="" aria-label="首页"><!--[--><!--]--> 首页 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/backend/" class="router-link-active" aria-label="Java技术栈"><!--[--><!--]--> Java技术栈 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/ops/" class="" aria-label="Ops相关"><!--[--><!--]--> Ops相关 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/boutique/" class="" aria-label="杂货铺"><!--[--><!--]--> 杂货铺 <!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://github.com/AmosWang0626/AmosWang0626.github.io" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading">Java基础 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/backend/java/base/1-String.matches()性能测试.md" class="sidebar-item" aria-label="String.matches() 性能测试"><!--[--><!--]--> String.matches() 性能测试 <!--[--><!--]--></a><!----></li><li><a href="/backend/java/base/2-万能的HelloWorld.md" class="sidebar-item" aria-label="万能的HelloWorld"><!--[--><!--]--> 万能的HelloWorld <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading">Java并发编程 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/backend/java/concurrent/1-Java高效并发.md" class="sidebar-item" aria-label="Java高效并发"><!--[--><!--]--> Java高效并发 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading">设计模式 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/backend/design_mode/1-设计模式概述.md" class="sidebar-item" aria-label="设计模式概述"><!--[--><!--]--> 设计模式概述 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading active">MySQL <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/backend/mysql/1-MySQL概览.md" class="sidebar-item active" aria-label="MySQL概览"><!--[--><!--]--> MySQL概览 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="mysql概览" tabindex="-1"><a class="header-anchor" href="#mysql概览" aria-hidden="true">#</a> MySQL概览</h1><h2 id="mysql存储引擎" tabindex="-1"><a class="header-anchor" href="#mysql存储引擎" aria-hidden="true">#</a> MySQL存储引擎</h2><blockquote><p>MyISAM、InnoDB、Memory</p></blockquote><h4 id="myisam" tabindex="-1"><a class="header-anchor" href="#myisam" aria-hidden="true">#</a> MyISAM</h4><p>不支持事务，不支持外键约束，索引文件和数据文件分开。内存中可以缓存更多的索引，对查询性能会更好，适用于那种少插入，多查询的场景。</p><p>经典案例：大数据场景下的报表系统。网站埋点日志、业务系统通过MySQL binlog同步业务数据，批量写入Hadoop后，在 T+1 进行离线批处理计算， 数据计算完，导入MySQL中，后边报表系统就可以直接从MySQL中查询已经计算好的数据，渲染成各种图，供他人使用。</p><p>但是在数据量非常多的情况下，几千万、几十亿数据时，MySQL是扛不住这么多数据的，一般建议单表500万以内数据量。</p><p>所以后来采用可配置化BI系统 + kylin + elastic search，支持大规模数据的复杂报表。</p><h4 id="innodb" tabindex="-1"><a class="header-anchor" href="#innodb" aria-hidden="true">#</a> InnoDB</h4><p>支持事务，强制要求主键，默认根据主键建立聚簇索引，支持外键约束。高并发（读写分离）、大数据量（分库分表）、高可用（主备切换）等相关成熟的数据库架构。</p><h2 id="mysql索引相关" tabindex="-1"><a class="header-anchor" href="#mysql索引相关" aria-hidden="true">#</a> MySQL索引相关</h2><h3 id="索引数据结构" tabindex="-1"><a class="header-anchor" href="#索引数据结构" aria-hidden="true">#</a> 索引数据结构</h3><blockquote><p>B树，B+树</p></blockquote><h5 id="b树" tabindex="-1"><a class="header-anchor" href="#b树" aria-hidden="true">#</a> B树</h5><ul><li>平衡的多路查找树，所有叶子结点都位于同一层。</li><li>一个5阶B树，每个结点最多有4个关键字。</li><li>每个结点都能存放数据或数据地址。</li></ul><h5 id="b-树" tabindex="-1"><a class="header-anchor" href="#b-树" aria-hidden="true">#</a> B+树</h5><ul><li>B树的升级版，只有叶子结点才保存数据，所以每次查找次数都相同，更稳定。</li><li>另外，所有的叶子节点数据构成了一个有序链表，范围查找时性能更高。</li><li>全节点遍历时，只需要遍历所有的叶子节点即可，遍历速度更快。</li></ul><h4 id="myisam引擎中的索引实现-b-树" tabindex="-1"><a class="header-anchor" href="#myisam引擎中的索引实现-b-树" aria-hidden="true">#</a> MyISAM引擎中的索引实现（B+树）</h4><p>MyISAM数据文件和索引文件是分开的，所以索引文件里的data都是指向数据文件中的一行。</p><h4 id="innodb引擎中的索引实现-b-树" tabindex="-1"><a class="header-anchor" href="#innodb引擎中的索引实现-b-树" aria-hidden="true">#</a> InnoDB引擎中的索引实现（B+树）</h4><ul><li><p>聚簇索引</p><blockquote><p>强制要求主键，默认根据主键建立一个聚簇索引。数据文件本身就存在于根据主键建立的聚簇索引中。</p><p>如果没有主键，MySQL会自动找一个唯一列、或者隐式定义一个主键DB_ROW_ID，以此来创建聚簇索引。</p></blockquote></li><li><p>非聚簇索引</p><ul><li>如果查询的列，索引中完全包含，也就是覆盖索引，直接从索引中返回数据即可。</li><li>如果查询的列，索引中不完全包含，那就会回表查询，根据索引中指向的地址，去聚簇索引中获取数据。</li></ul></li></ul><p>所以，在 InnoDB引擎里边，按照主键ID查询数据是很快的。</p><h4 id="innodb引擎两个建议" tabindex="-1"><a class="header-anchor" href="#innodb引擎两个建议" aria-hidden="true">#</a> InnoDB引擎两个建议</h4><ol><li>不推荐使用 UUID 作为主键</li><li>推荐使用 自增ID 作为主键</li></ol><p>原因如下：</p><ul><li>UUID 作为主键，键值32位字符串，多消耗磁盘空间，会使索引文件变大。</li><li>自增ID 是有序的，数据插入时，磁盘的顺序读写性能更高，也天然适合范围查找。</li><li>UUID 生成的字符串是无序的，插入时，频繁移动磁盘块，自然性能就会低一些。</li></ul><h2 id="索引使用规则" tabindex="-1"><a class="header-anchor" href="#索引使用规则" aria-hidden="true">#</a> 索引使用规则</h2><ol><li>全列匹配（联合索引，作为条件时要是有序的）</li><li>最左原则（如果没法全列匹配，要遵守最左原则，尽可能使最左的索引有较好区分度）</li><li>前缀匹配（like &quot;xxx%&quot;，%不能放前边&quot;%xxx%&quot;）</li><li>范围列匹配（符合最左原则才可以范围匹配，同时范围之后的无法使用索引）</li><li>函数不能使用索引</li></ol><p>索引缺点，注意事项</p><ul><li>插入性能会降低</li><li>尽量少创建索引，2~3个</li><li>索引区分度要高（id【推荐】、status(0, 1)【区分度太低】）</li></ul><h2 id="事务" tabindex="-1"><a class="header-anchor" href="#事务" aria-hidden="true">#</a> 事务</h2><h4 id="事务的acid" tabindex="-1"><a class="header-anchor" href="#事务的acid" aria-hidden="true">#</a> 事务的ACID</h4><ol><li>原子性（Atomic） <blockquote><p>要么一起成功，要么一起失败</p></blockquote></li><li>一致性（Consistency） <blockquote><p>SQL执行前后，数据是一致的</p></blockquote></li><li>隔离性（Isolation） <blockquote><p>多个事务之间不能相互干扰</p></blockquote></li><li>持久性（Durability） <blockquote><p>事务成功，修改的结果是持久的</p></blockquote></li></ol><h4 id="事务隔离级别" tabindex="-1"><a class="header-anchor" href="#事务隔离级别" aria-hidden="true">#</a> 事务隔离级别</h4><ol><li>读未提交 <blockquote><p>可以读到其他事务没有提交的数据，如果别的事务后边没提交，这就不对了</p></blockquote></li><li>读已提交(RC)【Oracle默认】 <blockquote><p>可以读到已提交的数据。</p></blockquote></li><li>可重复读(RR)【MySQL默认】 <blockquote><p>通过MVCC来保证，在一个事务里边，多次读同一行数据，无论别的事务怎么修改，本事务读到的内容是一样的。</p></blockquote></li><li>串行化 <blockquote><p>用来解决幻读的，不过这样会导致性能低下。</p></blockquote></li></ol><h4 id="mysql-innodb如何实现可重复读-rr" tabindex="-1"><a class="header-anchor" href="#mysql-innodb如何实现可重复读-rr" aria-hidden="true">#</a> MySQL InnoDB如何实现可重复读(RR)</h4><p>在 InnoDB 引擎下，会为每一行保存两个事务ID：(1)创建的事务ID；(2)删除的事务ID。</p><h5 id="删除" tabindex="-1"><a class="header-anchor" href="#删除" aria-hidden="true">#</a> 删除</h5><table><thead><tr><th>id</th><th>name</th><th>创建事务ID</th><th>删除事务ID</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>120</td><td>空</td></tr><tr><td>2</td><td>李四</td><td>121</td><td>空</td></tr></tbody></table><ul><li>事务120进来，插入了一条数据id=1</li><li>事务121进来，插入了一条数据id=2</li><li>事务122进来，删除了id=1的数据</li></ul><p><strong>之后的数据长这样</strong>：</p><table><thead><tr><th>id</th><th>name</th><th>创建事务ID</th><th>删除事务ID</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>120</td><td>122</td></tr><tr><td>2</td><td>李四</td><td>121</td><td>空</td></tr></tbody></table><p>那么，事务120还能查到id=1的数据吗？</p><blockquote><p>答：可以的，事务120读取的时候，可以读到 创建事务ID &lt;= 当前事务ID，以及当前事务ID &lt;= 删除事务ID。</p></blockquote><h5 id="修改" tabindex="-1"><a class="header-anchor" href="#修改" aria-hidden="true">#</a> 修改</h5><table><thead><tr><th>id</th><th>name</th><th>创建事务ID</th><th>删除事务ID</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>120</td><td>空</td></tr><tr><td>2</td><td>李四</td><td>121</td><td>空</td></tr></tbody></table><ul><li>事务120进来，插入了一条数据id=1</li><li>事务121进来，插入了一条数据id=2</li><li>事务122进来，修改id=1的数据，name=小明</li></ul><p><strong>之后的数据长这样</strong>：</p><table><thead><tr><th>id</th><th>name</th><th>创建事务ID</th><th>删除事务ID</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>120</td><td>空</td></tr><tr><td>2</td><td>李四</td><td>121</td><td>空</td></tr><tr><td>1</td><td>小明</td><td>122</td><td>空</td></tr></tbody></table><p>那么，事务120查询id=1的数据的name是啥呢？</p><blockquote><p>答：张三。事务120读取的时候，只能读到 创建事务ID &lt;= 当前事务ID 的数据；InnoDB里边， 如果有不同的事务修改同一行数据，此时每个事务都会创建一个数据行的快照再进行修改。</p></blockquote><h2 id="mysql锁" tabindex="-1"><a class="header-anchor" href="#mysql锁" aria-hidden="true">#</a> MySQL锁</h2><h3 id="_1-表锁、行锁" tabindex="-1"><a class="header-anchor" href="#_1-表锁、行锁" aria-hidden="true">#</a> （1）表锁、行锁</h3><h4 id="表锁" tabindex="-1"><a class="header-anchor" href="#表锁" aria-hidden="true">#</a> 表锁</h4><p>在MyISAM引擎下，一般MyISAM会加表锁：</p><ul><li>执行查询时，会默认加个表共享锁，也就是表读锁，这个时候别人只能来查，不能写数据；</li><li>写操作的时候，会给表加独占锁，也就是表写锁，别人不能读也不能写。</li></ul><p>在InnoDB引擎下：</p><ul><li>意向共享锁，就是加共享行锁的时候，必须先加这个共享表锁；</li><li>意向排它锁，就是给某行加排它锁的时候，必须先给表加排它锁。</li></ul><p>注意：这个表锁，是InnoDB引擎自动加的，无需手动加锁。</p><h4 id="行锁" tabindex="-1"><a class="header-anchor" href="#行锁" aria-hidden="true">#</a> 行锁</h4><p>InnoDB的行锁有共享锁（S）和排它锁（X）两种。</p><ul><li>共享锁：多个事务可以加共享锁读同一行数据，但是别的事务不能写这行数据；</li><li>排它锁：就是一个事务可以写这行数据，其他事务只能读，不能写。</li></ul><hr><ul><li><p>自动加锁</p><ul><li>insert/update/delete操作会加行级排它锁。</li><li>select，InnoDB不会加锁。因为InnoDB默认实现了可重复读，也就是MVCC机制，多个事务随便读，各自有快照。</li></ul></li><li><p>手动加锁</p><ul><li>手动加共享锁：<code>select * from table where id = 1 lock in share mode</code>，然后其他事务就不能来修改这行数据了。</li><li>手动加排它锁：<code>select * from table where id = 1 for update</code>，然后其他事务修改会被hang住，慎用！</li></ul></li></ul><h3 id="_2-悲观锁和乐观锁" tabindex="-1"><a class="header-anchor" href="#_2-悲观锁和乐观锁" aria-hidden="true">#</a> （2）悲观锁和乐观锁</h3><p>悲观锁：</p><blockquote><p>只能我自己来操作，别人都操作不了。</p></blockquote><p><code>select * fromo table where id = 1 for update</code></p><p>乐观锁：</p><blockquote><p>通过版本控制，如果别人修改了，我就不修改了，或者重新获取新值，再进行修改。有点CAS的意思。</p></blockquote><div class="language-sql ext-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">select</span> id<span class="token punctuation">,</span> username<span class="token punctuation">,</span> version
<span class="token keyword">from</span> <span class="token keyword">table</span>
<span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token keyword">update</span> <span class="token keyword">table</span>
<span class="token keyword">set</span> username <span class="token operator">=</span> <span class="token string">&#39;New Name&#39;</span><span class="token punctuation">,</span>
    version  <span class="token operator">=</span> <span class="token comment">#{old_version} + 1</span>
<span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span>
  <span class="token operator">and</span> version <span class="token operator">=</span> <span class="token comment">#{old_version};</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="_3-死锁" tabindex="-1"><a class="header-anchor" href="#_3-死锁" aria-hidden="true">#</a> （3）死锁</h3><p>多个事务竞争同一把锁，就会形成死锁。</p><p>实战：</p><blockquote><p>死锁相对常见，如下</p></blockquote><ol><li>有些时候，调整事务隔离级别可以解决。 <ul><li>查看事务隔离级别 <code>SELECT @@tx_isolation;</code></li><li>修改数据库默认事务隔离级别；代码中配置事务隔离级别；多租户下，连接池设置事务隔离级别</li></ul></li><li>看下哪里死锁了 <ul><li><code>Lock wait timeout exceeded; try restarting transaction</code></li><li>查看死锁SQL <code>select * from information_schema.innodb_trx;</code></li></ul></li></ol><h2 id="mysql调优手段" tabindex="-1"><a class="header-anchor" href="#mysql调优手段" aria-hidden="true">#</a> MySQL调优手段</h2><ul><li>尽可能单表查询，加上索引，join相关的逻辑放在代码里边</li><li>explain对应SQL，看是否命中了索引，索引扫描了多少行</li></ul><h2 id="主键数据类型选型" tabindex="-1"><a class="header-anchor" href="#主键数据类型选型" aria-hidden="true">#</a> 主键数据类型选型</h2><p>推荐使用自增ID，那么如果自增ID用完了怎么办？</p><ul><li><p>int</p><ul><li>带符号 -21,4748,3648 ~ 21,4748,3647</li><li>无符号 0 ~ 42,9496,7295（约42亿）</li></ul></li><li><p>bigint</p><ul><li>带符号 -922,3372,0368,5477,5808 ~ 922,3372,0368,5477,5807</li><li>无符号 0 ~ 1844,6744,0737,0955,1615</li></ul></li></ul><ol><li>默认是int类型，自增ID最大值 4294967295，可以改为bigint类型 <ul><li>怎么修改，直接Alter修改肯定需要停服，大概率是可以停服的</li><li>如果不可以停服，主从切换，分别修改</li></ul></li><li>另外，单表数据量过亿，系统肯定早就应该重构了 <ul><li>分库分表概括一下</li><li>分库分表主键ID可采用雪花算法，或者其他分布式ID解决方案</li></ul></li></ol><h2 id="幂等性" tabindex="-1"><a class="header-anchor" href="#幂等性" aria-hidden="true">#</a> 幂等性</h2><p><code>INSERT INTO ... ON DUPLICATE KEY UPDATE</code> 语法，不存在时插⼊，存在时更新，是天然⽀持幂等性的。</p><p><code>REPLACE INTO ...</code> 如果唯一键存在就更新。</p><p><code>INSERT IGNORE INTO ...</code> 如果唯一键存在就不插入，也可以解决并发插入的问题。</p><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 1833063210@qq.com">amos.wang</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app.91e03dc1.js" defer></script>
  </body>
</html>
