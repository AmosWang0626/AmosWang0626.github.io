import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{e as i,h as e,o as t}from"./app-UN-z0Sab.js";const n={};function l(h,a){return t(),i("div",null,a[0]||(a[0]=[e(`<h2 id="cas-与-aqs" tabindex="-1"><a class="header-anchor" href="#cas-与-aqs"><span>CAS 与 AQS</span></a></h2><h2 id="_1-cas是什么" tabindex="-1"><a class="header-anchor" href="#_1-cas是什么"><span>1. CAS是什么</span></a></h2><p>Compare-and-Swap 或者 Compare-and-Set 简称 CAS。</p><p><strong>CAS操作是原子性的</strong>，CAS指令需要有三个操作数，分别是内存位置（在Java中可以简单地理解为变量的内存地址，用V表示）、旧的预期值（用A表示）和准备设置的新值（用B表示）。CAS指令执行时，当且仅当V符合A时，处理器才会用B更新V的值，否则它就不执行更新。</p><p>在 JDK 5之后，Java类库中才开始使用CAS操作，该操作由<code>sun.misc.Unsafe</code>类里面的<code>compareAndSwapInt()</code>和<code>compareAndSwapLong()</code>等几个方法包装提供。<code>HotSpot</code>虚拟机在内部对这些方法做了特殊处理，即时编译出来的结果就是一条平台相关的处理器CAS指令，没有方法调用的过程，或者可以认为是无条件内联进去了。不过由于Unsafe类在设计上就不是提供给用户程序调用的类【<code>Unsafe::getUnsafe()</code>的代码中限制了只有启动类加载器（<code>Bootstrap ClassLoader</code>）加载的Class才能访问它】，因此在<code>JDK 9</code>之前只有Java类库可以使用CAS，譬如<code>J.U.C</code>包里面的整数原子类，其中的<code>compareAndSet()</code>和<code>getAndIncrement()</code>等方法都使用了Unsafe类的CAS操作来实现。而如果用户程序也有使用CAS操作的需求，那要么就采用反射手段突破<code>Unsafe</code>的访问限制，要么就只能通过Java类库API来间接使用它。直到<code>JDK 9</code>之后，Java类库才在<code>VarHandle</code>类里开放了面向用户程序使用的<code>CAS</code>操作。</p><p><a href="https://github.com/AmosWang0626/chaos/blob/master/chaos-advanced/src/main/java/com/amos/advanced/java/UnsafeCasStudy.java" target="_blank" rel="noopener noreferrer">JDK 8 使用 Unsafe.compareAndSwapInt() 示例</a></p><h2 id="_2-aqs是什么" tabindex="-1"><a class="header-anchor" href="#_2-aqs是什么"><span>2. AQS是什么</span></a></h2><p>基本结构：状态位 state + Node 双向链表；</p><p>获取锁：通过 CAS 修改 state（state + 1）；要是没获取到锁，就放进双向链表里边；</p><p>释放锁：释放锁，修改 state（state - 1）。当 state = 0，操作队列，解锁队首。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> transient</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> volatile</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Node</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> head</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 队首</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> transient</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> volatile</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Node</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> tail</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 队尾</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> volatile</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> state</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 状态位</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    volatile</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> waitStatus</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 等待状态</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    volatile</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Node</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> prev</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 前</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    volatile</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Node</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> next</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 后</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    volatile</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Thread</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 当前线程</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3-reentrantlock" tabindex="-1"><a class="header-anchor" href="#_3-reentrantlock"><span>3. ReentrantLock</span></a></h2><blockquote><p>针对的问题，jdk1.6之前，只要加上 synchronized，不管有没有并发，都会加上重量级锁，导致性能低下。</p><p>Doug Lea 大神开发了JUC包，给出了加锁第二方案。</p></blockquote><p><a href="https://blog.csdn.net/java_lyvee/article/details/98966684" target="_blank" rel="noopener noreferrer">子路老师：JUC AQS ReentrantLock源码分析（一）</a></p><blockquote><p>偷个懒，把子路老师的文章放这了。<br> 还有一个原因就是子路老师说的，不要会一点技术，还没理解全面，就往博客上写，间接导致了博客泛滥，误人子弟。</p></blockquote><h2 id="_4-其他并发集合" tabindex="-1"><a class="header-anchor" href="#_4-其他并发集合"><span>4. 其他并发集合</span></a></h2><ul><li>CountDownLatch 类似计数器，都执行完成时退出。</li><li>Semaphore 类似停车位，有进有出，满需等待。</li><li>CyclicBarrier 类似发令枪，线程都就绪时，并发执行。</li><li>ReentrantReadWriteLock 读写锁。</li></ul>`,17)]))}const p=s(n,[["render",l],["__file","02-ConcurrentPackage.html.vue"]]),d=JSON.parse('{"path":"/java/jdk_concurrent/02-ConcurrentPackage.html","title":"并发包内容","lang":"zh-CN","frontmatter":{"title":"并发包内容","date":"2020-05-16T00:00:00.000Z","category":["JDK并发编程"],"order":2,"description":"CAS 与 AQS 1. CAS是什么 Compare-and-Swap 或者 Compare-and-Set 简称 CAS。 CAS操作是原子性的，CAS指令需要有三个操作数，分别是内存位置（在Java中可以简单地理解为变量的内存地址，用V表示）、旧的预期值（用A表示）和准备设置的新值（用B表示）。CAS指令执行时，当且仅当V符合A时，处理器才会用B...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/java/jdk_concurrent/02-ConcurrentPackage.html"}],["meta",{"property":"og:site_name","content":"JAVA技术学习笔记"}],["meta",{"property":"og:title","content":"并发包内容"}],["meta",{"property":"og:description","content":"CAS 与 AQS 1. CAS是什么 Compare-and-Swap 或者 Compare-and-Set 简称 CAS。 CAS操作是原子性的，CAS指令需要有三个操作数，分别是内存位置（在Java中可以简单地理解为变量的内存地址，用V表示）、旧的预期值（用A表示）和准备设置的新值（用B表示）。CAS指令执行时，当且仅当V符合A时，处理器才会用B..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-23T04:02:20.000Z"}],["meta",{"property":"article:published_time","content":"2020-05-16T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-23T04:02:20.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"并发包内容\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-05-16T00:00:00.000Z\\",\\"dateModified\\":\\"2025-03-23T04:02:20.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Amos Wang\\",\\"url\\":\\"https://github.com/AmosWang0626\\"}]}"]]},"git":{"createdTime":1742702540000,"updatedTime":1742702540000,"contributors":[{"name":"amos.wang","username":"amos.wang","email":"1833063210@qq.com","commits":1,"url":"https://github.com/amos.wang"}]},"readingTime":{"minutes":2.48,"words":745},"filePathRelative":"java/jdk_concurrent/02-ConcurrentPackage.md","localizedDate":"2020年5月16日","excerpt":"<h2>CAS 与 AQS</h2>\\n<h2>1. CAS是什么</h2>\\n<p>Compare-and-Swap 或者 Compare-and-Set 简称 CAS。</p>\\n<p><strong>CAS操作是原子性的</strong>，CAS指令需要有三个操作数，分别是内存位置（在Java中可以简单地理解为变量的内存地址，用V表示）、旧的预期值（用A表示）和准备设置的新值（用B表示）。CAS指令执行时，当且仅当V符合A时，处理器才会用B更新V的值，否则它就不执行更新。</p>\\n<p>在 JDK 5之后，Java类库中才开始使用CAS操作，该操作由<code>sun.misc.Unsafe</code>类里面的<code>compareAndSwapInt()</code>和<code>compareAndSwapLong()</code>等几个方法包装提供。<code>HotSpot</code>虚拟机在内部对这些方法做了特殊处理，即时编译出来的结果就是一条平台相关的处理器CAS指令，没有方法调用的过程，或者可以认为是无条件内联进去了。不过由于Unsafe类在设计上就不是提供给用户程序调用的类【<code>Unsafe::getUnsafe()</code>的代码中限制了只有启动类加载器（<code>Bootstrap ClassLoader</code>）加载的Class才能访问它】，因此在<code>JDK 9</code>之前只有Java类库可以使用CAS，譬如<code>J.U.C</code>包里面的整数原子类，其中的<code>compareAndSet()</code>和<code>getAndIncrement()</code>等方法都使用了Unsafe类的CAS操作来实现。而如果用户程序也有使用CAS操作的需求，那要么就采用反射手段突破<code>Unsafe</code>的访问限制，要么就只能通过Java类库API来间接使用它。直到<code>JDK 9</code>之后，Java类库才在<code>VarHandle</code>类里开放了面向用户程序使用的<code>CAS</code>操作。</p>","autoDesc":true}');export{p as comp,d as data};
