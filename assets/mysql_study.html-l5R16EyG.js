import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{e as t,h as l,o as e}from"./app-3VcPeY_i.js";const s={};function n(d,i){return e(),t("div",null,i[0]||(i[0]=[l(`<h2 id="mysql存储引擎" tabindex="-1"><a class="header-anchor" href="#mysql存储引擎"><span>MySQL存储引擎</span></a></h2><blockquote><p>MyISAM、InnoDB、Memory</p></blockquote><h4 id="myisam" tabindex="-1"><a class="header-anchor" href="#myisam"><span>MyISAM</span></a></h4><p>不支持事务，不支持外键约束，索引文件和数据文件分开。内存中可以缓存更多的索引，对查询性能会更好，适用于那种少插入，多查询的场景。</p><p>经典案例：大数据场景下的报表系统。网站埋点日志、业务系统通过MySQL binlog同步业务数据，批量写入Hadoop后，在 T+1 进行离线批处理计算，<br> 数据计算完，导入MySQL中，后边报表系统就可以直接从MySQL中查询已经计算好的数据，渲染成各种图，供他人使用。</p><p>但是在数据量非常多的情况下，几千万、几十亿数据时，MySQL是扛不住这么多数据的，一般建议单表500万以内数据量。</p><p>所以后来采用可配置化BI系统 + kylin + elastic search，支持大规模数据的复杂报表。</p><h4 id="innodb" tabindex="-1"><a class="header-anchor" href="#innodb"><span>InnoDB</span></a></h4><p>支持事务，强制要求主键，默认根据主键建立聚簇索引，支持外键约束。高并发（读写分离）、大数据量（分库分表）、高可用（主备切换）等相关成熟的数据库架构。</p><h2 id="mysql索引相关" tabindex="-1"><a class="header-anchor" href="#mysql索引相关"><span>MySQL索引相关</span></a></h2><h3 id="索引数据结构" tabindex="-1"><a class="header-anchor" href="#索引数据结构"><span>索引数据结构</span></a></h3><blockquote><p>B树，B+树</p></blockquote><h5 id="b树" tabindex="-1"><a class="header-anchor" href="#b树"><span>B树</span></a></h5><ul><li>平衡的多路查找树，所有叶子结点都位于同一层。</li><li>一个5阶B树，每个结点最多有4个关键字。</li><li>每个结点都能存放数据或数据地址。</li></ul><h5 id="b-树" tabindex="-1"><a class="header-anchor" href="#b-树"><span>B+树</span></a></h5><ul><li>B树的升级版，只有叶子结点才保存数据，所以每次查找次数都相同，更稳定。</li><li>另外，所有的叶子节点数据构成了一个有序链表，范围查找时性能更高。</li><li>全节点遍历时，只需要遍历所有的叶子节点即可，遍历速度更快。</li></ul><h4 id="myisam引擎中的索引实现-b-树" tabindex="-1"><a class="header-anchor" href="#myisam引擎中的索引实现-b-树"><span>MyISAM引擎中的索引实现（B+树）</span></a></h4><p>MyISAM数据文件和索引文件是分开的，所以索引文件里的data都是指向数据文件中的一行。</p><h4 id="innodb引擎中的索引实现-b-树" tabindex="-1"><a class="header-anchor" href="#innodb引擎中的索引实现-b-树"><span>InnoDB引擎中的索引实现（B+树）</span></a></h4><ul><li><p>聚簇索引</p><blockquote><p>强制要求主键，默认根据主键建立一个聚簇索引。数据文件本身就存在于根据主键建立的聚簇索引中。</p><p>如果没有主键，MySQL会自动找一个唯一列、或者隐式定义一个主键DB_ROW_ID，以此来创建聚簇索引。</p></blockquote></li><li><p>非聚簇索引</p><ul><li>如果查询的列，索引中完全包含，也就是覆盖索引，直接从索引中返回数据即可。</li><li>如果查询的列，索引中不完全包含，那就会回表查询，根据索引中指向的地址，去聚簇索引中获取数据。</li></ul></li></ul><p>所以，在 InnoDB引擎里边，按照主键ID查询数据是很快的。</p><h4 id="innodb引擎两个建议" tabindex="-1"><a class="header-anchor" href="#innodb引擎两个建议"><span>InnoDB引擎两个建议</span></a></h4><ol><li>不推荐使用 UUID 作为主键</li><li>推荐使用 自增ID 作为主键</li></ol><p>原因如下：</p><ul><li>UUID 作为主键，键值32位字符串，多消耗磁盘空间，会使索引文件变大。</li><li>自增ID 是有序的，数据插入时，磁盘的顺序读写性能更高，也天然适合范围查找。</li><li>UUID 生成的字符串是无序的，插入时，频繁移动磁盘块，自然性能就会低一些。</li></ul><h2 id="索引使用规则" tabindex="-1"><a class="header-anchor" href="#索引使用规则"><span>索引使用规则</span></a></h2><ol><li>全列匹配（联合索引，作为条件时要是有序的）</li><li>最左原则（如果没法全列匹配，要遵守最左原则，尽可能使最左的索引有较好区分度）</li><li>前缀匹配（like &quot;xxx%&quot;，%不能放前边&quot;%xxx%&quot;）</li><li>范围列匹配（符合最左原则才可以范围匹配，同时范围之后的无法使用索引）</li><li>函数不能使用索引</li></ol><p>索引缺点，注意事项</p><ul><li>插入性能会降低</li><li>尽量少创建索引，2~3个</li><li>索引区分度要高（id【推荐】、status(0, 1)【区分度太低】）</li></ul><h2 id="事务" tabindex="-1"><a class="header-anchor" href="#事务"><span>事务</span></a></h2><h4 id="事务的acid" tabindex="-1"><a class="header-anchor" href="#事务的acid"><span>事务的ACID</span></a></h4><ol><li>原子性（Atomic） <blockquote><p>要么一起成功，要么一起失败</p></blockquote></li><li>一致性（Consistency） <blockquote><p>SQL执行前后，数据是一致的</p></blockquote></li><li>隔离性（Isolation） <blockquote><p>多个事务之间不能相互干扰</p></blockquote></li><li>持久性（Durability） <blockquote><p>事务成功，修改的结果是持久的</p></blockquote></li></ol><h4 id="事务隔离级别" tabindex="-1"><a class="header-anchor" href="#事务隔离级别"><span>事务隔离级别</span></a></h4><ol><li>读未提交 <blockquote><p>可以读到其他事务没有提交的数据，如果别的事务后边没提交，这就不对了</p></blockquote></li><li>读已提交(RC)【Oracle默认】 <blockquote><p>可以读到已提交的数据。</p></blockquote></li><li>可重复读(RR)【MySQL默认】 <blockquote><p>通过MVCC来保证，在一个事务里边，多次读同一行数据，无论别的事务怎么修改，本事务读到的内容是一样的。</p></blockquote></li><li>串行化 <blockquote><p>用来解决幻读的，不过这样会导致性能低下。</p></blockquote></li></ol><h4 id="mysql-innodb如何实现可重复读-rr" tabindex="-1"><a class="header-anchor" href="#mysql-innodb如何实现可重复读-rr"><span>MySQL InnoDB如何实现可重复读(RR)</span></a></h4><p>在 InnoDB 引擎下，会为每一行保存两个事务ID：(1)创建的事务ID；(2)删除的事务ID。</p><h5 id="删除" tabindex="-1"><a class="header-anchor" href="#删除"><span>删除</span></a></h5><table><thead><tr><th>id</th><th>name</th><th>创建事务ID</th><th>删除事务ID</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>120</td><td>空</td></tr><tr><td>2</td><td>李四</td><td>121</td><td>空</td></tr></tbody></table><ul><li>事务120进来，插入了一条数据id=1</li><li>事务121进来，插入了一条数据id=2</li><li>事务122进来，删除了id=1的数据</li></ul><p><strong>之后的数据长这样</strong>：</p><table><thead><tr><th>id</th><th>name</th><th>创建事务ID</th><th>删除事务ID</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>120</td><td>122</td></tr><tr><td>2</td><td>李四</td><td>121</td><td>空</td></tr></tbody></table><p>那么，事务120还能查到id=1的数据吗？</p><blockquote><p>答：可以的，事务120读取的时候，可以读到 创建事务ID &lt;= 当前事务ID，以及当前事务ID &lt;= 删除事务ID。</p></blockquote><h5 id="修改" tabindex="-1"><a class="header-anchor" href="#修改"><span>修改</span></a></h5><table><thead><tr><th>id</th><th>name</th><th>创建事务ID</th><th>删除事务ID</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>120</td><td>空</td></tr><tr><td>2</td><td>李四</td><td>121</td><td>空</td></tr></tbody></table><ul><li>事务120进来，插入了一条数据id=1</li><li>事务121进来，插入了一条数据id=2</li><li>事务122进来，修改id=1的数据，name=小明</li></ul><p><strong>之后的数据长这样</strong>：</p><table><thead><tr><th>id</th><th>name</th><th>创建事务ID</th><th>删除事务ID</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>120</td><td>空</td></tr><tr><td>2</td><td>李四</td><td>121</td><td>空</td></tr><tr><td>1</td><td>小明</td><td>122</td><td>空</td></tr></tbody></table><p>那么，事务120查询id=1的数据的name是啥呢？</p><blockquote><p>答：张三。事务120读取的时候，只能读到 创建事务ID &lt;= 当前事务ID 的数据；InnoDB里边，<br> 如果有不同的事务修改同一行数据，此时每个事务都会创建一个数据行的快照再进行修改。</p></blockquote><h2 id="mysql锁" tabindex="-1"><a class="header-anchor" href="#mysql锁"><span>MySQL锁</span></a></h2><h3 id="_1-表锁、行锁" tabindex="-1"><a class="header-anchor" href="#_1-表锁、行锁"><span>（1）表锁、行锁</span></a></h3><h4 id="表锁" tabindex="-1"><a class="header-anchor" href="#表锁"><span>表锁</span></a></h4><p>在MyISAM引擎下，一般MyISAM会加表锁：</p><ul><li>执行查询时，会默认加个表共享锁，也就是表读锁，这个时候别人只能来查，不能写数据；</li><li>写操作的时候，会给表加独占锁，也就是表写锁，别人不能读也不能写。</li></ul><p>在InnoDB引擎下：</p><ul><li>意向共享锁，就是加共享行锁的时候，必须先加这个共享表锁；</li><li>意向排它锁，就是给某行加排它锁的时候，必须先给表加排它锁。</li></ul><p>注意：这个表锁，是InnoDB引擎自动加的，无需手动加锁。</p><h4 id="行锁" tabindex="-1"><a class="header-anchor" href="#行锁"><span>行锁</span></a></h4><p>InnoDB的行锁有共享锁（S）和排它锁（X）两种。</p><ul><li>共享锁：多个事务可以加共享锁读同一行数据，但是别的事务不能写这行数据；</li><li>排它锁：就是一个事务可以写这行数据，其他事务只能读，不能写。</li></ul><hr><ul><li><p>自动加锁</p><ul><li>insert/update/delete操作会加行级排它锁。</li><li>select，InnoDB不会加锁。因为InnoDB默认实现了可重复读，也就是MVCC机制，多个事务随便读，各自有快照。</li></ul></li><li><p>手动加锁</p><ul><li>手动加共享锁：<code>select * from table where id = 1 lock in share mode</code>，然后其他事务就不能来修改这行数据了。</li><li>手动加排它锁：<code>select * from table where id = 1 for update</code>，然后其他事务修改会被hang住，慎用！</li></ul></li></ul><h3 id="_2-悲观锁和乐观锁" tabindex="-1"><a class="header-anchor" href="#_2-悲观锁和乐观锁"><span>（2）悲观锁和乐观锁</span></a></h3><p>悲观锁：</p><blockquote><p>只能我自己来操作，别人都操作不了。</p></blockquote><p><code>select * fromo table where id = 1 for update</code></p><p>乐观锁：</p><blockquote><p>通过版本控制，如果别人修改了，我就不修改了，或者重新获取新值，再进行修改。有点CAS的意思。</p></blockquote><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id, username, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">version</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> table</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">update</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> table</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">set</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> username </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;New Name&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    version</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">  =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> #{old_version} + </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  and</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> version</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> #{old_version};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-死锁" tabindex="-1"><a class="header-anchor" href="#_3-死锁"><span>（3）死锁</span></a></h3><p>多个事务竞争同一把锁，就会形成死锁。</p><p>实战：</p><blockquote><p>死锁相对常见，如下</p></blockquote><ol><li>有些时候，调整事务隔离级别可以解决。 <ul><li>查看事务隔离级别 <code>SELECT @@tx_isolation;</code></li><li>修改数据库默认事务隔离级别；代码中配置事务隔离级别；多租户下，连接池设置事务隔离级别</li></ul></li><li>看下哪里死锁了 <ul><li><code>Lock wait timeout exceeded; try restarting transaction</code></li><li>查看死锁SQL <code>select * from information_schema.innodb_trx;</code></li></ul></li></ol><h2 id="mysql调优手段" tabindex="-1"><a class="header-anchor" href="#mysql调优手段"><span>MySQL调优手段</span></a></h2><ul><li>尽可能单表查询，加上索引，join相关的逻辑放在代码里边</li><li>explain对应SQL，看是否命中了索引，索引扫描了多少行</li></ul><h2 id="主键数据类型选型" tabindex="-1"><a class="header-anchor" href="#主键数据类型选型"><span>主键数据类型选型</span></a></h2><p>推荐使用自增ID，那么如果自增ID用完了怎么办？</p><ul><li><p>int</p><ul><li>带符号 -21,4748,3648 ~ 21,4748,3647</li><li>无符号 0 ~ 42,9496,7295（约42亿）</li></ul></li><li><p>bigint</p><ul><li>带符号 -922,3372,0368,5477,5808 ~ 922,3372,0368,5477,5807</li><li>无符号 0 ~ 1844,6744,0737,0955,1615</li></ul></li></ul><ol><li>默认是int类型，自增ID最大值 4294967295，可以改为bigint类型 <ul><li>怎么修改，直接Alter修改肯定需要停服，大概率是可以停服的</li><li>如果不可以停服，主从切换，分别修改</li></ul></li><li>另外，单表数据量过亿，系统肯定早就应该重构了 <ul><li>分库分表概括一下</li><li>分库分表主键ID可采用雪花算法，或者其他分布式ID解决方案</li></ul></li></ol><h2 id="幂等性" tabindex="-1"><a class="header-anchor" href="#幂等性"><span>幂等性</span></a></h2><p><code>INSERT INTO ... ON DUPLICATE KEY UPDATE</code> 语法，不存在时插⼊，存在时更新，是天然⽀持幂等性的。</p><p><code>REPLACE INTO ...</code> 如果唯一键存在就更新。</p><p><code>INSERT IGNORE INTO ...</code> 如果唯一键存在就不插入，也可以解决并发插入的问题。</p>`,85)]))}const p=a(s,[["render",n],["__file","mysql_study.html.vue"]]),r=JSON.parse('{"path":"/java/others/mysql_study.html","title":"MySQL概览","lang":"zh-CN","frontmatter":{"title":"MySQL概览","date":"2021-04-10T00:00:00.000Z","category":["MySQL"],"description":"MySQL存储引擎 MyISAM、InnoDB、Memory MyISAM 不支持事务，不支持外键约束，索引文件和数据文件分开。内存中可以缓存更多的索引，对查询性能会更好，适用于那种少插入，多查询的场景。 经典案例：大数据场景下的报表系统。网站埋点日志、业务系统通过MySQL binlog同步业务数据，批量写入Hadoop后，在 T+1 进行离线批处理...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/java/others/mysql_study.html"}],["meta",{"property":"og:site_name","content":"JAVA技术学习笔记"}],["meta",{"property":"og:title","content":"MySQL概览"}],["meta",{"property":"og:description","content":"MySQL存储引擎 MyISAM、InnoDB、Memory MyISAM 不支持事务，不支持外键约束，索引文件和数据文件分开。内存中可以缓存更多的索引，对查询性能会更好，适用于那种少插入，多查询的场景。 经典案例：大数据场景下的报表系统。网站埋点日志、业务系统通过MySQL binlog同步业务数据，批量写入Hadoop后，在 T+1 进行离线批处理..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-06T15:29:00.000Z"}],["meta",{"property":"article:published_time","content":"2021-04-10T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-06T15:29:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL概览\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-04-10T00:00:00.000Z\\",\\"dateModified\\":\\"2025-03-06T15:29:00.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Amos Wang\\",\\"url\\":\\"https://github.com/AmosWang0626\\"}]}"]]},"git":{"createdTime":1686316913000,"updatedTime":1741274940000,"contributors":[{"name":"amos.wang","username":"amos.wang","email":"1833063210@qq.com","commits":2,"url":"https://github.com/amos.wang"}]},"readingTime":{"minutes":8.15,"words":2445},"filePathRelative":"java/others/mysql_study.md","localizedDate":"2021年4月10日","excerpt":"<h2>MySQL存储引擎</h2>\\n<blockquote>\\n<p>MyISAM、InnoDB、Memory</p>\\n</blockquote>\\n<h4>MyISAM</h4>\\n<p>不支持事务，不支持外键约束，索引文件和数据文件分开。内存中可以缓存更多的索引，对查询性能会更好，适用于那种少插入，多查询的场景。</p>\\n<p>经典案例：大数据场景下的报表系统。网站埋点日志、业务系统通过MySQL binlog同步业务数据，批量写入Hadoop后，在 T+1 进行离线批处理计算，<br>\\n数据计算完，导入MySQL中，后边报表系统就可以直接从MySQL中查询已经计算好的数据，渲染成各种图，供他人使用。</p>","autoDesc":true}');export{p as comp,r as data};
