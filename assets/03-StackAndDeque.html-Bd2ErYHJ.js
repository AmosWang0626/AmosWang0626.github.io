import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{e,h as a,o as t}from"./app-UN-z0Sab.js";const n={};function d(o,s){return t(),e("div",null,s[0]||(s[0]=[a(`<h3 id="stack与deque的区别-以及为什么推荐使用deque" tabindex="-1"><a class="header-anchor" href="#stack与deque的区别-以及为什么推荐使用deque"><span>Stack与Deque的区别，以及为什么推荐使用Deque？</span></a></h3><h3 id="概述" tabindex="-1"><a class="header-anchor" href="#概述"><span>概述</span></a></h3><p>在 Java 中，<code>Stack</code> 和 <code>Deque</code> 的设计差异反映了不同时期集合框架的理念。<code>Stack</code> 作为早期设计存在一些明显缺陷，而 <code>Deque</code> 接口的引入（Java 6）解决了这些问题并提供了更现代的替代方案。以下是它们的主要设计问题对比：</p><hr><h3 id="_1-继承关系与设计耦合" tabindex="-1"><a class="header-anchor" href="#_1-继承关系与设计耦合"><span>1. <strong>继承关系与设计耦合</strong></span></a></h3><ul><li><p><strong><code>Stack</code> 的问题</strong>：<br><code>Stack</code> <strong>直接继承自 <code>Vector</code></strong>（一个线程安全的动态数组实现），导致其设计高度耦合于 <code>Vector</code> 的实现细节。</p><ul><li><strong>违反「组合优于继承」原则</strong>：<code>Stack</code> 通过继承获得 <code>Vector</code> 的同步逻辑，但栈的逻辑（后进先出，LIFO）与动态数组的随机访问特性并不完全匹配。</li><li><strong>扩展性差</strong>：由于 Java 单继承的限制，<code>Stack</code> 无法灵活扩展其他类。</li></ul></li><li><p><strong><code>Deque</code> 的优势</strong>：<br><code>Deque</code> 是一个<strong>接口</strong>（如 <code>ArrayDeque</code>、<code>LinkedList</code> 是其实现），允许开发者根据需要选择底层数据结构，避免与具体实现耦合。</p><ul><li>例如：<code>ArrayDeque</code> 基于数组实现（高效随机访问），<code>LinkedList</code> 基于链表（高效插入删除）。</li></ul></li></ul><hr><h3 id="_2-方法命名与功能局限性" tabindex="-1"><a class="header-anchor" href="#_2-方法命名与功能局限性"><span>2. <strong>方法命名与功能局限性</strong></span></a></h3><ul><li><p><strong><code>Stack</code> 的问题</strong>：</p><ul><li><strong>方法命名不直观</strong>：<code>Stack</code> 的方法（如 <code>push()</code>, <code>pop()</code>）直接继承自 <code>Vector</code>，但 <code>Vector</code> 的方法（如 <code>addElement()</code>）并不符合栈的语义。</li><li><strong>功能单一</strong>：仅支持 LIFO 操作，无法灵活支持其他场景（如双端操作）。</li></ul></li><li><p><strong><code>Deque</code> 的优势</strong>：</p><ul><li><strong>统一且丰富的 API</strong>：<code>Deque</code> 同时支持 <strong>栈（LIFO）</strong> 和 <strong>队列（FIFO）</strong> 的操作，方法命名更清晰（如栈的操作：入栈<code>push()</code>, 出栈<code>pop()</code>, 队列的操作：入队列<code>offer()</code>, 出队列<code>poll()</code>）。</li><li><strong>双端操作</strong>：允许在头部和尾部添加/删除元素（例如 <code>addFirst()</code>, <code>addLast()</code>），灵活性更高。</li></ul></li></ul><hr><h3 id="_3-线程安全与性能" tabindex="-1"><a class="header-anchor" href="#_3-线程安全与性能"><span>3. <strong>线程安全与性能</strong></span></a></h3><ul><li><p><strong><code>Stack</code> 的问题</strong>：</p><ul><li><strong>强制同步导致性能低下</strong>：由于继承自 <code>Vector</code>，所有方法默认使用 <code>synchronized</code> 关键字实现同步。这在单线程场景下会带来不必要的性能损耗。</li><li><strong>伪线程安全</strong>：虽然单个方法原子，但复合操作（如 <code>isEmpty()</code> + <code>pop()</code>）仍需外部同步。</li></ul></li><li><p><strong><code>Deque</code> 的优势</strong>：</p><ul><li><strong>性能优化</strong>：<code>Deque</code> 的默认实现（如 <code>ArrayDeque</code>）<strong>非线程安全</strong>，避免了同步开销，性能显著优于 <code>Stack</code>（尤其在单线程场景）。</li><li><strong>按需选择线程安全实现</strong>： <ul><li>需要线程安全时，可使用 <code>ConcurrentLinkedDeque</code>（无锁并发实现）。</li><li>或通过 <code>Collections.synchronizedDeque()</code> 包装非线程安全的 <code>Deque</code>。</li></ul></li></ul></li></ul><hr><h3 id="_4-历史遗留与现代替代" tabindex="-1"><a class="header-anchor" href="#_4-历史遗留与现代替代"><span>4. <strong>历史遗留与现代替代</strong></span></a></h3><ul><li><p><strong><code>Stack</code> 的问题</strong>：</p><ul><li><strong>过时的设计</strong>：<code>Stack</code> 是 Java 1.0 时代的产物，其设计未遵循现代集合框架的接口-实现分离原则。</li><li><strong>官方废弃建议</strong>：Java 官方文档明确建议优先使用 <code>Deque</code> 实现栈功能。</li></ul></li><li><p><strong><code>Deque</code> 的优势</strong>：</p><ul><li><strong>符合现代集合框架标准</strong>：<code>Deque</code> 作为接口，完美融入 Java 集合框架（如实现 <code>Iterable</code>、支持泛型等）。</li><li><strong>广泛适用性</strong>：既能作为栈，也能作为队列或双端队列使用，减少代码冗余。</li></ul></li></ul><hr><h3 id="代码示例对比" tabindex="-1"><a class="header-anchor" href="#代码示例对比"><span>代码示例对比</span></a></h3><h4 id="使用-stack-不推荐" tabindex="-1"><a class="header-anchor" href="#使用-stack-不推荐"><span>使用 <code>Stack</code>（不推荐）：</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Stack</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> stack </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Stack</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">stack</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">push</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;A&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">stack</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">push</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;B&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> top </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> stack</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">pop</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // &quot;B&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="使用-deque-推荐" tabindex="-1"><a class="header-anchor" href="#使用-deque-推荐"><span>使用 <code>Deque</code>（推荐）：</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Deque</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> deque </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ArrayDeque</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">deque</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">push</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;A&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">deque</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">push</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;B&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> top </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> deque</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">pop</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // &quot;B&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 还可以作为队列使用</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">deque</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">offerLast</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;C&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> head </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> deque</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">pollFirst</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // &quot;A&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="总结-stack-的主要设计缺陷" tabindex="-1"><a class="header-anchor" href="#总结-stack-的主要设计缺陷"><span>总结：<code>Stack</code> 的主要设计缺陷</span></a></h3><table><thead><tr><th>问题维度</th><th><code>Stack</code> 的缺陷</th><th><code>Deque</code> 的改进</th></tr></thead><tbody><tr><td><strong>继承关系</strong></td><td>继承 <code>Vector</code>，耦合度高</td><td>基于接口，实现灵活</td></tr><tr><td><strong>功能扩展</strong></td><td>仅支持 LIFO 操作</td><td>支持栈、队列、双端操作</td></tr><tr><td><strong>线程安全</strong></td><td>强制同步导致性能低下</td><td>非线程安全实现（可按需选择并发版本）</td></tr><tr><td><strong>方法设计</strong></td><td>方法命名与功能单一</td><td>统一且丰富的 API</td></tr><tr><td><strong>现代性</strong></td><td>过时，官方不推荐</td><td>符合 Java 集合框架标准</td></tr></tbody></table><hr><h3 id="何时使用-deque-代替-stack" tabindex="-1"><a class="header-anchor" href="#何时使用-deque-代替-stack"><span>何时使用 <code>Deque</code> 代替 <code>Stack</code>？</span></a></h3><ul><li><strong>单线程环境</strong>：优先使用 <code>ArrayDeque</code>（性能最优）。</li><li><strong>高并发场景</strong>：使用 <code>ConcurrentLinkedDeque</code>。</li><li><strong>需兼容旧代码</strong>：使用 <code>Collections.synchronizedDeque()</code> 包装非线程安全的 <code>Deque</code>，但需注意复合操作的同步。</li></ul><p><code>Deque</code> 的引入解决了 <code>Stack</code> 的历史遗留问题，提供了更高效、灵活且符合现代编程实践的替代方案。</p>`,28)]))}const r=i(n,[["render",d],["__file","03-StackAndDeque.html.vue"]]),c=JSON.parse('{"path":"/java/jdk_base/03-StackAndDeque.html","title":"Stack与Deque的区别？","lang":"zh-CN","frontmatter":{"title":"Stack与Deque的区别？","index":true,"icon":"laptop-code","date":"2025-03-10T00:00:00.000Z","category":["JDK基础源码"],"order":3,"description":"Stack与Deque的区别，以及为什么推荐使用Deque？ 概述 在 Java 中，Stack 和 Deque 的设计差异反映了不同时期集合框架的理念。Stack 作为早期设计存在一些明显缺陷，而 Deque 接口的引入（Java 6）解决了这些问题并提供了更现代的替代方案。以下是它们的主要设计问题对比： 1. 继承关系与设计耦合 Stack 的问题...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/java/jdk_base/03-StackAndDeque.html"}],["meta",{"property":"og:site_name","content":"JAVA技术学习笔记"}],["meta",{"property":"og:title","content":"Stack与Deque的区别？"}],["meta",{"property":"og:description","content":"Stack与Deque的区别，以及为什么推荐使用Deque？ 概述 在 Java 中，Stack 和 Deque 的设计差异反映了不同时期集合框架的理念。Stack 作为早期设计存在一些明显缺陷，而 Deque 接口的引入（Java 6）解决了这些问题并提供了更现代的替代方案。以下是它们的主要设计问题对比： 1. 继承关系与设计耦合 Stack 的问题..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-15T15:21:40.000Z"}],["meta",{"property":"article:published_time","content":"2025-03-10T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-15T15:21:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Stack与Deque的区别？\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-03-10T00:00:00.000Z\\",\\"dateModified\\":\\"2025-03-15T15:21:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Amos Wang\\",\\"url\\":\\"https://github.com/AmosWang0626\\"}]}"]]},"git":{"createdTime":1741880187000,"updatedTime":1742052100000,"contributors":[{"name":"amos.wang","username":"amos.wang","email":"1833063210@qq.com","commits":1,"url":"https://github.com/amos.wang"},{"name":"amos.wang","username":"amos.wang","email":"daoyuan0626@gmail.com","commits":2,"url":"https://github.com/amos.wang"}]},"readingTime":{"minutes":3.59,"words":1078},"filePathRelative":"java/jdk_base/03-StackAndDeque.md","localizedDate":"2025年3月10日","excerpt":"<h3>Stack与Deque的区别，以及为什么推荐使用Deque？</h3>\\n<h3>概述</h3>\\n<p>在 Java 中，<code>Stack</code> 和 <code>Deque</code> 的设计差异反映了不同时期集合框架的理念。<code>Stack</code> 作为早期设计存在一些明显缺陷，而 <code>Deque</code> 接口的引入（Java 6）解决了这些问题并提供了更现代的替代方案。以下是它们的主要设计问题对比：</p>\\n<hr>\\n<h3>1. <strong>继承关系与设计耦合</strong></h3>\\n<ul>\\n<li>\\n<p><strong><code>Stack</code> 的问题</strong>：<br>\\n<code>Stack</code> <strong>直接继承自 <code>Vector</code></strong>（一个线程安全的动态数组实现），导致其设计高度耦合于 <code>Vector</code> 的实现细节。</p>\\n<ul>\\n<li><strong>违反「组合优于继承」原则</strong>：<code>Stack</code> 通过继承获得 <code>Vector</code> 的同步逻辑，但栈的逻辑（后进先出，LIFO）与动态数组的随机访问特性并不完全匹配。</li>\\n<li><strong>扩展性差</strong>：由于 Java 单继承的限制，<code>Stack</code> 无法灵活扩展其他类。</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong><code>Deque</code> 的优势</strong>：<br>\\n<code>Deque</code> 是一个<strong>接口</strong>（如 <code>ArrayDeque</code>、<code>LinkedList</code> 是其实现），允许开发者根据需要选择底层数据结构，避免与具体实现耦合。</p>\\n<ul>\\n<li>例如：<code>ArrayDeque</code> 基于数组实现（高效随机访问），<code>LinkedList</code> 基于链表（高效插入删除）。</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{r as comp,c as data};
